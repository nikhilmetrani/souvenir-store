package sg.edu.nus.iss.se23pt2.pos;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.AccessDeniedException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

import sg.edu.nus.iss.se23pt2.pos.exception.CreationFailedException;
import sg.edu.nus.iss.se23pt2.pos.exception.InsufficientQuantityException;
import sg.edu.nus.iss.se23pt2.pos.exception.InvalidTransactionException;
import sg.edu.nus.iss.se23pt2.pos.util.DateUtil;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : SouvenirStore
//  @ File Name : ShoppingCart.java
//  @ Date : 3/8/2015
//  @ Author : Nikhil Metrani
//  @ Author: Niu Yiming (added methods: getHighestDiscount, calcDiscPmt, calcFinalPmt)
//  @ Author:Debasish(added methods getTotalPriceBeforeDiscount,getPayableAmount,calculateNewPoints)
//

public class ShoppingCart {

    private ArrayList<Item> items;
    private ArrayList<Discount> discounts;
    private Discount discount;
    private Customer customer;
    private int points=0;
    private String date;
    private double totalPriceBeforeDisc = 0.0d;
    private double amountPaid = 0.0d;

    public ShoppingCart() {
        this.items = new ArrayList<Item>();
        this.customer = new Customer();
        this.points = 0;
        this.discount = null;
        //TO-DO
        //this.date =
    }

    public void setItems(ArrayList<Item> items) {
        this.items = items;
    }

    public ArrayList<Item> getItems() {
        return this.items;
    }

    public Discount getDiscount() {
        return discount;
    }

    public void setDiscount(Discount discount) {
        this.discount = discount;
    }

    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
    }


    public int getPoints() {
        return points;
    }

    public void setPoints(int points) {
        this.points = points;
    }

    public void setAmountPaid(double amountPaid){
        this.amountPaid = amountPaid;
    }

    public double getAmountPaid(){
        return this.amountPaid;
    }

    public String getDate(){
        return this.date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    public Item addToCart(Item item){
        this.items.add(item);
        return item;
    }

    public void removeFromCart(Item item){
        this.items.remove(item);
    }


    public void removeFromCart(int index){ 
        this.items.remove(index);
    }

    public Item addToCart(Product p, int quantity) {
        //TO-DO
        Item item = new Item();
        return item;
    }

    public Item removeFromCart(Product p, int quantity) {
        //TO-DO
        Item item = new Item();
        return item;
    }


    public void setMember(Member m) {
        this.customer = m;
    }

    public Member getMember() {
        //TO-DO - type cast customer to member
        if(this.customer instanceof Member)
            return (Member)this.customer;
        else
            return null;
    }


    // Get the highest discount based on customer type and shopping date
    // Get the highest discount based on customer type and shopping date
    public double getHighestDiscount(Customer cust, ArrayList<Discount> discounts
            , String transDate) {

        Discount disc;
        double highestDesc = 0;
        try{
            // Members are eligible for all discounts
            if (cust instanceof Member) {
                for(int i = 0; i <= discounts.size()-1; i++) {
                    disc = discounts.get(i);
                    if(disc.isValid(disc, transDate) && disc.getDiscPct() > highestDesc) {
                        highestDesc = disc.getDiscPct();
                        this.discount = disc;
                    }
                }
                return highestDesc;
            } else {
                for(int i = 0; i <= discounts.size()-1; i++) {
                    // Public are only eligible for discounts that applicable to all customers
                    if(discounts.get(i).getAppTo().equals("A")) {
                        disc = discounts.get(i);
                        if(disc.isValid(disc, transDate) && disc.getDiscPct() > highestDesc) {
                            highestDesc = disc.getDiscPct();
                            this.discount = disc;
                        }
                    }
                }
                return highestDesc;
            }
        }catch(ParseException e){
            e.printStackTrace();
            this.discount = null;
            return 0;
        }
    } 

    /** Created by JV to use instance objects**/
    public double getHighestDiscount(ArrayList<Discount> discounts) {
        String transDate = DateUtil.getCurrentDateAsString();
        double highestDesc = 0;
        try{
            for(Discount discount : discounts) {
                if(discount.isValid(this.getCustomer(), transDate) && discount.getDiscPct() > highestDesc) {
                    highestDesc = discount.getDiscPct();
                    this.discount = discount;
                }
            }
            return highestDesc;
        }catch(ParseException e){
            e.printStackTrace();
            this.discount = null;
            return 0;
        }
    }

    //returns total price of the items after final check out
    public Double getTotalPriceBeforeDiscount(List<Item> finalItemList) {
        //iterate the list of items to fetch the total price of the items
        if(finalItemList != null && !finalItemList.isEmpty()){
            for(Item item : finalItemList){
                if(item != null){
                    totalPriceBeforeDisc = totalPriceBeforeDisc+item.getPrice()*item.getQuantity();
                }
            }
        }
        return totalPriceBeforeDisc;
    }

    /** Created by JV to use instance objects**/
    public Double getTotalPriceBeforeDiscount() {
        //iterate the list of items to fetch the total price of the items
        double totalPriceBeforeDisc = 0.0d;
        if(this.items != null && !this.items.isEmpty()){
            for(Item item : this.items){
                if(item != null){
                    totalPriceBeforeDisc = totalPriceBeforeDisc+(item.getPrice()*item.getQuantity());
                }
            }
        }
        return new BigDecimal(totalPriceBeforeDisc).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();
    }

    // To calculate the discounted payment amount
    public double getTotalPriceAfterDiscount(Customer cust, double totalPriceBeforeDisc
            , ArrayList<Discount> discounts,String transactionDate) throws ParseException {
        double finalDiscount = this.getHighestDiscount(cust, discounts,transactionDate);
        return totalPriceBeforeDisc*(100-finalDiscount)/100;
    }

    /** Created by JV to use instance objects**/
    public double getTotalPriceAfterDiscount() {
        double finalDiscount = (this.discount!=null)?discount.getDiscPct():0.0d;
        return getTotalPriceBeforeDiscount()*(100-finalDiscount)/100;
    }

    // To calculate the final payment based on member's decision if or not redeeming loyalty points
    // This method is open only to members. For public customers the discount amount is considered final
    public double calcFinalPmt(Member member, double totalPriceAfterDiscount, int pointsRedeemed) {
    	int pointsToDollar = 0;
        int dollarsToPoints = 0;
        double payableAmount = totalPriceAfterDiscount;
        double finalAmountToBePaid = 0.0d;

        //if Member wants to redeem the points then this block of code will be executed to calculate the final amount
        if(this.getMember() != null){
            if(member.getLoyaltyPoints() >= pointsRedeemed){
                pointsToDollar = (int) ((5d/100d)*pointsRedeemed);
            }
        }

        finalAmountToBePaid = BigDecimal.valueOf(payableAmount - pointsToDollar).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); //According to Requirement $5=100 Points redeemed

        if(finalAmountToBePaid < 0){
            dollarsToPoints = (int)(Math.abs(finalAmountToBePaid) + payableAmount)/10;
        }
        else{
            dollarsToPoints = (int)finalAmountToBePaid/10;
        }
        
        if(member != null){
        	member.deductLoyaltyPoints(pointsRedeemed);
        	member.addLoyaltyPoints(dollarsToPoints);
        }

        return finalAmountToBePaid;
    }

    /** Created by JV to use instance objects**/
    public double calcFinalPmt() {
        int pointsToDollar = 0;
        int dollarsToPoints = 0;
        double payableAmount = this.getTotalPriceAfterDiscount();
        double finalAmountToBePaid = 0.0d;
        int pointsRedeemed = this.getPoints();

        //if Member wants to redeem the points then this block of code will be executed to calculate the final amount
        if(this.getMember() != null){
            if(this.getMember().getLoyaltyPoints() >= pointsRedeemed){
                pointsToDollar = (int) ((5d/100d)*pointsRedeemed);
            }
        }

        finalAmountToBePaid = BigDecimal.valueOf(payableAmount - pointsToDollar).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); //According to Requirement $5=100 Points redeemed

        if(finalAmountToBePaid < 0){
            /* This means all payment is covered by Loyalty points. 
             * On confirmation of the payment, the excess points needs to be calcualted and 
             * should be added back to the member.loyaltyPoints 
             * 
             */
            dollarsToPoints = (int)(Math.abs(finalAmountToBePaid) + payableAmount)/10;
        }
        else{
            dollarsToPoints = (int)payableAmount/10;
        }
        
        if(this.getMember() != null){
            this.getMember().deductLoyaltyPoints(pointsRedeemed);
            this.getMember().addLoyaltyPoints(dollarsToPoints);
        }

        return finalAmountToBePaid;
    }

    // Calculate the discounted payment based on customer type
    public double getPayableAmount(Customer customer,double totalPriceAfterDisc,boolean isRedeemable,int pointsRedeemed) {
        
    	int pointsToDollar = 0;
        double finalAmountToBePaid = totalPriceAfterDisc;
        //if Member wants to redeem the points then this block of code will be executed to calculate the final amount
        if(customer != null && customer instanceof Member){
            Member member = getMember();
            if(member.getLoyaltyPoints() >= pointsRedeemed && isRedeemable){
                pointsToDollar = (int) ((5d/100d)*pointsRedeemed);
            }
        }
        finalAmountToBePaid = BigDecimal.valueOf(finalAmountToBePaid - pointsToDollar).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); //According to Requirement $5=100 Points redeemed
        if(finalAmountToBePaid < 0){
            finalAmountToBePaid = 0.0;
        }
        return finalAmountToBePaid;
    }

    /** Created by JV to use instance objects**/
    public double getPayableAmount() {
        int pointsToDollar = 0;
        double finalAmountToBePaid = this.getTotalPriceAfterDiscount();
        //if Member wants to redeem the points then this block of code will be executed to calculate the final amount
        if(this.getMember() != null){
            int pointsRedeemed = this.getPoints();
            if(this.getMember().getLoyaltyPoints() >= pointsRedeemed){
                pointsToDollar = (int) ((5d/100d)*pointsRedeemed);
            }
        }
        finalAmountToBePaid = BigDecimal.valueOf(finalAmountToBePaid - pointsToDollar).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); //According to Requirement $5=100 Points redeemed
        if(finalAmountToBePaid < 0){
            /* This means all payment is covered by Loyalty points. 
             * On confirmation of the payment, the excess points needs to be calcualted and 
             * should be added back to the member.loyaltyPoints 
             * 
             */
            finalAmountToBePaid = 0.0;
        }
        return finalAmountToBePaid;
    }

    private double calculateNewPoints(Double price,int pointsRedeemed,int currentLoyalityPoints,Member member){
        /*if clause is applicable when discounted amount(say 50.5) is equal to or more than the points the user wants to redeem(45) with current loyality
         * points of the user is 70. In such case, updated loyality points = loyality points left[points related to final price - redeemed] + (current loyality points - points redeemed)= (50.5-45)+(70-45)
         *
         * else clause  is applicable when discounted amount(say 50.5) is less than the points the user wants to redeem(55) with current loyality
         * points of the user is 70. In such case, updated loyality points = current loyality points + points related to final price (50.5+70)
        */
        double updatedLoyalityPoints = 0.0;
        double finalAmountToBePaid = 0.0;
        if(member.isRedeemable() && price.intValue() >= pointsRedeemed && currentLoyalityPoints >= pointsRedeemed){
            finalAmountToBePaid = price - pointsRedeemed;
            member.deductLoyaltyPoints(pointsRedeemed);
            //updatedLoyalityPoints = member.getLoyaltyPoints()+;
            //member.addLoyaltyPoints((int)Math.round(finalAmountToBePaid));
            return finalAmountToBePaid;
        }else{
            //updatedLoyalityPoints = price+currentLoyalityPoints;
            member.addLoyaltyPoints((int)Math.round(price/10d));  //According to requirement
            finalAmountToBePaid = price;
            return finalAmountToBePaid;
        }
    }

    /** Created by JV to use instance objects**/
    private double calculateNewPoints(int pointsRedeemed){
        double finalAmountToBePaid = this.getTotalPriceAfterDiscount();
        //if Member wants to redeem the points then this block of code will be executed to calculate the final amount
        if(this.getMember() != null){
            if(this.getMember().getLoyaltyPoints() >= pointsRedeemed){
                finalAmountToBePaid = BigDecimal.valueOf(finalAmountToBePaid - ((5d/100d)*pointsRedeemed)).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); //According to Requirement $5=100 Points redeemed
                if(finalAmountToBePaid > 0)
                    return finalAmountToBePaid;
                else{ 
                    /* This means all payment is covered by Loyalty points. 
                     * On confirmation of the payment, the excess points needs to be calcualted and 
                     * should be added back to the member.loyaltyPoints 
                     * 
                     */
                    return 0;  
                }
            }
        }
        return finalAmountToBePaid;
    }

    public Transaction confirmTransaction(Customer customer,ArrayList<Item> itemList,Discount finalDiscount,String transactionDate) {
        Transaction transaction = new Transaction();
        transaction.setCustomer(customer);
        transaction.setItems(itemList);
        transaction.setDiscount(finalDiscount);
        transaction.setDate(transactionDate);
        return transaction;
    }

    /** Created by JV to use instance objects
     * @throws IOException 
     * @throws CreationFailedException 
     * @throws InvalidTransactionException 
     * @throws AccessDeniedException **/
    public Transaction confirmTransaction(SouvenirStore store) throws InsufficientQuantityException, Exception {
        calcFinalPmt();
        deductInventory(store.getInventory());
        Transaction transaction = new Transaction();
        transaction.setId(Integer.parseInt(SequenceGenerator.getInstance().getNextSequence(SequenceGenerator.TRANSACTION_SEQ)));
        transaction.setCustomer(this.customer);
        transaction.setItems(this.items);
        transaction.setDiscount(this.discount);
        transaction.setDate(DateUtil.getCurrentDateAsString());
        store.setTransaction(transaction);
        return transaction;
    }

    private void deductInventory(Inventory inventory) throws InsufficientQuantityException{
        for(Item item : items){
            item.getProduct().deductQuantity(item.getQuantity());
        }
    }

}
